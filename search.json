[
  {
    "objectID": "index_bak.html",
    "href": "index_bak.html",
    "title": "De.KCD - Data Management Platform on the Cloud",
    "section": "",
    "text": "Process and documentation on adapting a docker-based Data Management platform, Seek4Science, to Kubernetes, and using it in the cloud.\n\nGeneral Introduction\n\n\nLearning Kubernetes\n\n\nBenefits and costs\n\n\nQuick overview\n\n\nFrom Docker compose to manifest\n\nMedium data storage needs\nLarge data storage needs\n\n\n\nFrom manifest to Helm chart\n\n\nOther solutions\n\n\nScalability\n\n\nDatabases\n\n\nSecurity\n\n\nGoing to an assembly\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "static_md/tutorials_links.html",
    "href": "static_md/tutorials_links.html",
    "title": "Tutorials’ Links",
    "section": "",
    "text": "Editing these pages\n\nStackEdit, a Wysiwyg MD editor\n\n\n\nDocker & Docker compose\n\nDocker manual\n\n\n\nOpenStack\n\nYoutube: Introduction to OpenStack\nYoutube: Alternative Introduction to OpenStack\n\n\n\nKubernetes\n\nYoutube: Kubernetes crash course\nTutorials at IBM\n\n\n\nIdentity Management\n\nOauth on Wikipedia\nOpenID\nAAI: Elixir Authentication and Authorization Infrastructure\nAuthentik: a simplified but powerful identity server\nLDAP on Wikipedia\n\n\n\nAnsible\n\nGetting started - Official documentation\n\n\n\nTerraform\n\nTerraform vs Kubernetes\n\n\n\nData Management\n\nDM - Corporate\n\nKnowledge Graphs - SciBite\nWhat is a Semantic Knowledge Graph? - SciBite\n\n\n\nDM - Tools and Apps\n\nOpen Knowledge Foundation – For a fair, sustainable and open future\nCKAN - The open source data management system\nREDCap – Research Electronic Data Capture - Universitätsrechenzentrum Heidelberg\nTool assembly | RDMkit\nTool assembly: Galaxy | RDMkit\nTool assembly: Plant Phenomics | RDMkit\nGitHub - BiBiServ/bibigrid: BiBiGrid is a tool for an easy cluster setup inside a cloud environment.\nVault by HashiCorp\nData Stewardship Wizard\nELIXIR-CONVERGE deliverables | ELIXIR\nELIXIR-CONVERGE | ELIXIR\nAbout - TeSS (Training eSupport System)\nDSW Cloud for ELIXIR\nHome | re3data.org\nCancer Galaxy\nTool assembly: Marine Metagenomics | RDMkit\nMIAPPE\nFAIR Cookbook\nFAIR Wizard\nFAIRsharing | Home\nFAIR Solutions Products\nRucio - Scientific Data Management\nOverture - Home\nGitHub - irods/irods: Open Source Data Management Software\nZenodo - Google Search\nFAIRmat - FAIRmat\nELIXIR CONVERGE WP3: Common Data Management Toolkit | ELIXIR\nNOMAD\nZenodo\nMaterials - OpenWetWare\nDataPLAN, generate a data management plan DMP easily\nAruna | The data orchestration engine\nFAIRshare | FAIR Data Innovations Hub\n\n\n\nDM - Misc\n\nFORCE11 – The Future of Research Communications and e-Scholarship\nNFDI4Biodiversity - YouTube\nData Management and Data Literacy - YouTube\n\n\n\nTechnical tools and languages\n\nDiscover GO\n\n\nWritten with the help of StackEdit."
  },
  {
    "objectID": "pages/TechPlatformDecisionTree.html",
    "href": "pages/TechPlatformDecisionTree.html",
    "title": "Technical Platform decision tree for Data Management Platforms",
    "section": "",
    "text": "Here we will provide a decision tree on when to use which solution. It will try to take most factors into account (as in the availability of technical support, if a Cloud is already available…).",
    "crumbs": [
      "Home",
      "Technical Platform decision tree for Data Management Platforms"
    ]
  },
  {
    "objectID": "pages/DM_planning.html",
    "href": "pages/DM_planning.html",
    "title": "DataManagement - Planning",
    "section": "",
    "text": "A great introduction for Data Management can be found here and a cookbook (with examples for Life Science) here",
    "crumbs": [
      "Home",
      "Data Management Principles",
      "DataManagement - Planning"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html",
    "href": "pages/Backups_and_security.html",
    "title": "Backups and Security",
    "section": "",
    "text": "One generally important aspect of Data Management and data usage is to know which data to store and how to store it.\n\n\nIn many countries storage of personal information is strictly regulated. In the EU, storage of personal data can be done only with consent, must be accessible by the user, can be deleted upon request and can be stored only for a limited time.\nTODO: Add links\nWhen some research data is linked to person, it is advised to pseudonymize or to anonymize the data.\n\n\n\n\n\n\nImportant\n\n\n\nThe limitation of data storage for personal information includes backups",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#personal-data",
    "href": "pages/Backups_and_security.html#personal-data",
    "title": "Backups and Security",
    "section": "",
    "text": "In many countries storage of personal information is strictly regulated. In the EU, storage of personal data can be done only with consent, must be accessible by the user, can be deleted upon request and can be stored only for a limited time.\nTODO: Add links\nWhen some research data is linked to person, it is advised to pseudonymize or to anonymize the data.\n\n\n\n\n\n\nImportant\n\n\n\nThe limitation of data storage for personal information includes backups",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#defence-need-to-be-always-a-success-attack-need-only-one",
    "href": "pages/Backups_and_security.html#defence-need-to-be-always-a-success-attack-need-only-one",
    "title": "Backups and Security",
    "section": "Defence need to be always a success, attack need only one",
    "text": "Defence need to be always a success, attack need only one\nOne very important rule of security is that the attacker needs only one success. So it does not matter if many attempts are unsuccessful. They only need to try again. Thus defenders must adapt and monitor. It should be avoiding known vulnerabilies while trying to care for unknown ones.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#general-dispositions",
    "href": "pages/Backups_and_security.html#general-dispositions",
    "title": "Backups and Security",
    "section": "General dispositions",
    "text": "General dispositions\nDefault user not root (or super user if Windows)\nCareful with the paths and their access rights\nSymbolic links\nDatabase user, schema protections\ndifficult configurations and their possible issues (such as .htaccess or apache configuration in general)\n???",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#firewall",
    "href": "pages/Backups_and_security.html#firewall",
    "title": "Backups and Security",
    "section": "Firewall",
    "text": "Firewall",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#protections-against-attacks",
    "href": "pages/Backups_and_security.html#protections-against-attacks",
    "title": "Backups and Security",
    "section": "Protections against attacks",
    "text": "Protections against attacks",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#passwords-and-keys",
    "href": "pages/Backups_and_security.html#passwords-and-keys",
    "title": "Backups and Security",
    "section": "Passwords and keys",
    "text": "Passwords and keys",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#what-to-never-log-log-levels",
    "href": "pages/Backups_and_security.html#what-to-never-log-log-levels",
    "title": "Backups and Security",
    "section": "What to never log, log levels",
    "text": "What to never log, log levels\nLog are incredibly useful and should be used for debugging purpose and for security (they are often the only way to detect a tentative of intrusion/code injection).\nFor instance, it could be important to log all suspicious url paths are it might be a tentative of code injection, i.e. the attacker hoping that a mechanism in the code will execute a payload. A simple example would be executing raw SQL queries: * The URL subpath is /users/[name] where [name] is the name you want to look for. * The code will then simply execute “SELECT * FROM users WHERE name=[name];” * The attacker will use the URL subpath “/users/name”;DROP%20TABLE%20admin;%20 –“. * The code will execute”SELECT * FROM users WHERE name=“name”;DROP TABLE admin; –““. The end”–” is to comment the closing quote so it does not raise an error. * If the access right of the database is too permissible and an admin table exists, it will be dropped (but the example code is for illustration only, it might not work and in all cases it should not work).\nThis is a really well known and simple example and no modern web framework or API should allow such attacks nowadays. But the actual issue is with unknow vulnerability. Going back to this example, the web application should log something like:\n“2025-11-23_2:32:22 - Warning - incorrect characters in path:”/users/name”;DROP%20TABLE%20admin;%20 –”\nAnd that would allow to check what was attempted.\nBut logs are also plain text and, if accessed by an attacker, will be easy to comprehend. As such, there are information that should never been logged, and some that should be carefully logged:\n\nusername, password, keys, important DB table names (such as a users table used for login), should ideally never be written in a log file, even on DEBUG level and even on test. The reason for that is that everything that happen on test can happen on production. Amid a quick fix during an emergency, a test log entry can be forgiven and go to production. A fix on sensitive information can use the logs, but should be done in a very controlled way, without hurry, even during an emergency. A good way to proceed is to allow the log info only when needed, then switch it off (ideally remove the log entries) immediately after.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#what-to-never-store-or-never-in-reversible-format",
    "href": "pages/Backups_and_security.html#what-to-never-store-or-never-in-reversible-format",
    "title": "Backups and Security",
    "section": "What to never store (or never in “reversible” format)",
    "text": "What to never store (or never in “reversible” format)",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#know-your-infrastructure",
    "href": "pages/Backups_and_security.html#know-your-infrastructure",
    "title": "Backups and Security",
    "section": "Know your infrastructure",
    "text": "Know your infrastructure",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "pages/Backups_and_security.html#deleting-data",
    "href": "pages/Backups_and_security.html#deleting-data",
    "title": "Backups and Security",
    "section": "Deleting data",
    "text": "Deleting data",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Backups and Security"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "",
    "text": "Process and documentation on adapting a docker-based Data Management platform, Seek4Science, to Kubernetes, and using it in the cloud.",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#vocabulary",
    "href": "index.html#vocabulary",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Vocabulary",
    "text": "Vocabulary\n“Bare-Metal” is a bit of a misnomer, as it means originally using a computer without operating system, directly on the hardware (so using a low-level language such as ASM or C). But a bare-metal setup means a direct installation on a machine with the operating system.\n\n\n\n\n\n\nNote\n\n\n\nNote that an actual bare-metal setup could still be a viable option for specialised tasks: if it needs to be embedded (for a cheaper/more efficient solution on an specialised piece of hardware), if it needs to be highly performant, but in the later case it might be a better option to move the processing to the GPU (which is also a kind of bare-metal implementation). To choose to do so if out of scope for this document, but it is important to do so knowlingly as it could have a high cost (i.e. difficulty of maintenance)\n\n\nA Virtual Machine is a software solution that provide the functionality of a physical computer. It is possible (and generally needed) to install an operating system on it - most Virtual Machines will provide an easy way to do so, and using it is akin to using an actual computer.\nIt can be an emulation, “imitating” a computer enough to run its software, generally used for specific usages such as running deprecated operating systems. Qemu is one of the main ones. An emulation provides a full encapsulation so is in theory more secure - and exploit are fixable by software update.\nOr a virtualization, where the hosted machine is running directly or semi-directly on the physical hardware though an hypervisor that manages how the ressources are used: * full virtualization (simulate enough of the computer hardware to run a guest OS), and will need significant more resource than an actual physical computer, while providing a full encapsulation so in theory more security - and exploit are fixable by software update. * Hardware-assisted virtualization, where the hardware helps with the virtualization. Exploits using the hardware support might be difficult or impossible to fix, though exceptionals. * OS-level virtualization, where the operating system is sharing the resource for the guest OS. Docker and other container engines are using such virtualisation. The reason containers are called containers and not virtual machine is from the usage: instead of creating a virtual machine and setting it up with an operating system and subsequent pieces of software, they rely on fixed images that have an bare-minimal operating system (ideally) and layers of software to support the desired container. Once running, they are actually a virtual machine.\n\n\n\n\n\n\nNote\n\n\n\nA main protection against threat is being up-to-date: a recent or LTS - Long-Term-Support: that is supported for a long time - Operating System on a physical computer, Virtual Machine software, and virtualization software (which might have a direct support in the CPU).",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#vocabulary-1",
    "href": "index.html#vocabulary-1",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Vocabulary",
    "text": "Vocabulary",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#useful-things-to-know",
    "href": "index.html#useful-things-to-know",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Useful things to know",
    "text": "Useful things to know\nA docker image will be started (once used in a container) using an Entrypoint and/or a cmd. These can be listed by using docker inspect &lt;image id&gt;, but also individually by using docker inspect -f '{{.Config.Entrypoint}}' &lt;image id&gt; and docker inspect -f '{{.Config.Cmd}}' &lt;image id&gt;. This is useful in case something goes wrong inside a container to know how the container is supposed to start. To know more about cmd and Entrypoint, the official Docker documentation offer a great overview.\nChanging something that is part of the image is possible when running the container, but it will never be persistent and is generally a bad idea. One good case is when debugging an application, and if the debugged code is changed (in the code base) as soon as the issue is found.",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#advantages",
    "href": "index.html#advantages",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Advantages",
    "text": "Advantages",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#things-to-take-into-account",
    "href": "index.html#things-to-take-into-account",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Things to take into account",
    "text": "Things to take into account\nAdding parameters\nThe different types of volumes",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "index.html#namespaces-and-namespaces-collisions",
    "href": "index.html#namespaces-and-namespaces-collisions",
    "title": "De.KCD - Data Management Platform on the Cloud, step by step",
    "section": "Namespaces and namespaces collisions",
    "text": "Namespaces and namespaces collisions\nNamespacing is by using the name of the containing folder of the docker-compose file. Using the same name, even in different parent folder, will use the same namespace.",
    "crumbs": [
      "Home",
      "De.KCD - Data Management Platform on the Cloud, step by step"
    ]
  },
  {
    "objectID": "roadblocks.html",
    "href": "roadblocks.html",
    "title": "Scrap page: roadblocks, difficulties to remove or solutions to issues",
    "section": "",
    "text": "StatefulSet for temporary data (like a cache)\nBackup, K8s cronjob for backup, where to backup\nGitHub CI/CD to a cloud -&gt; security? (keys)\nAssembly on the cloud, Assembly between clouds (or cloud/servers) -&gt; security of set-up and exchange, who is monitoring (and how), where lies the responsibility? (GDPR, simple privacy concern, data theft, data loss, data leaks, data corruption)\nDaemonSet for monitoring and other tasks.",
    "crumbs": [
      "Home",
      "Scrap pages",
      "Scrap page: roadblocks, difficulties to remove or solutions to issues"
    ]
  },
  {
    "objectID": "pages/Volumes.html",
    "href": "pages/Volumes.html",
    "title": "Volumes",
    "section": "",
    "text": "Evidently, an important part of Data Management is the storage of data. From container to orchestrated system, data that need to be persisted is saved in volumes. Volume is a kind of abstract name for various solutions, which might be more adapted to certain cases.\nSome more advanced solutions might be easy to use, but hard to set-up and maintain. So their usage often depends on what is supported by the Cloud admin.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Volumes"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html",
    "href": "pages/Kubernetes_introduction.html",
    "title": "Kubernetes - introduction",
    "section": "",
    "text": "Try to explain clearly what the Kubernetes elements translate to and repeat it often to clarify this vocabulary as quickly as possible. Explain everything: so start from a simple (and stupid) solution and add to it. Do not drown: keep things structured so things are not confusing.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#seek-and-his-components",
    "href": "pages/Kubernetes_introduction.html#seek-and-his-components",
    "title": "Kubernetes - introduction",
    "section": "2.1 Seek and his components",
    "text": "2.1 Seek and his components",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#the-default-docker-compose",
    "href": "pages/Kubernetes_introduction.html#the-default-docker-compose",
    "title": "Kubernetes - introduction",
    "section": "2.2 The default Docker Compose",
    "text": "2.2 The default Docker Compose",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#what-could-benefit-from-a-cloud-setup",
    "href": "pages/Kubernetes_introduction.html#what-could-benefit-from-a-cloud-setup",
    "title": "Kubernetes - introduction",
    "section": "2.3 What could benefit from a cloud setup",
    "text": "2.3 What could benefit from a cloud setup",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#good-free-instructory-resources",
    "href": "pages/Kubernetes_introduction.html#good-free-instructory-resources",
    "title": "Kubernetes - introduction",
    "section": "3.1 Good free instructory resources",
    "text": "3.1 Good free instructory resources\n\n3.1.1 Tutorials and sandboxes\n\nKubernetes Crash Course for Absolute Beginners\nKubernetes online course, also containers (docker-based)\nKubernetes essentials, the site also offers many other useful tutorials\nOnline Kubernetes sandbox, Play with K8s and the corresponding workshop\n\n\n\n3.1.2 Simple Kubernetes setup\nOn Windows, the simplest way to run Kubernetes is probably using Docker Desktop. A simple Kubernetes setup is part of the options.\nOn Linux, there are lightweight setup using various approached. The main ones are:\n\nkubeadm, the official setup,\nk3s, a binary distribution, not availabe as a Windows executable, can be installed through WSL,\nk0s, another binary distribution, for Linux and Docker,\nRKE2, another binary distribution that also works on Windows,\nTalos, a light Linux distribution with an integrated Kubernetes setup, can also be set-up quickly using Docker,\nCanonical Kubernetes, a snap install for Ubuntu,\nMicroK8s, which can be installed on Windows and Mac but shouldn’t be used on production.\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to consider that, if some of these setup can be used in production (such as Talos or k3s), Kubernetes is a complex system and should be probably be managed by sys-admin persons, for ensuring fault-tolerance, backups and security.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#terminology-main-elements",
    "href": "pages/Kubernetes_introduction.html#terminology-main-elements",
    "title": "Kubernetes - introduction",
    "section": "3.2 Terminology & main elements",
    "text": "3.2 Terminology & main elements\nA first glance on Kubernetes can be very confusing. A big part of this confusion is due to a lot of “moving” parts with confusing names.\nA full list of terms can be found on the official documentation.\nThe maim terms/elements you should know are:\n\nCluster: the whole Kubernetes setup composed of several worker machines, called nodes. Some managed Kubernetes can support several clusters, so for instance give a cluster for one user.\nNode: one worker machine in Kubernetes, like a server. Can be a physical machine or a virtual machine.\nPod: the smallest object in Kubernetes, that will run one or several containers. The containers can be run by docker or other container engines.\nService: a fixed network endpoint to a container in Kubernetes. It allows to connect to an application in a Pod, without having this connection defined into the pod. Kubernetes often has one extra layer of access (compared to Docker Compose for instance) allowing a full decoupling of all elements. That makes it easier to change the configuration later on (automatically due to the need or from an user update).\nLabel: labels are used for Kubernetes to find the different elements.\nKubectl: the command line tool to communicate with the Kubernetes control center. With it you can create the object, update them, list them…\nManifest: the JSON or YAML file that define a Kubernetes object. Objects are all elements of Kubernetes: Deployments, Services, ReplicaSet, DaemonSet, …\n\nAnd generally, the applications are deployed as:\n\nReplicatSet: ask for a set numbers of Pods. Kubernetes will try to have the set number of pods running, and will restore this which might become unhealthy. The pods can be on any node and it is not guaranteed that Kubernetes will be able to get the right number of pods (if there isn’t enough resources typically). It is possible to influence on which node the pods will run using affinities, see Section 3.14\nDeployment: manages a ReplicaSet and provides rolling updates. It allows you to update an application without downtime by gradually replacing old Pods with new ones. If something goes wrong, you can roll back to a previous version.\nDaemonSet: ensures that one Pod runs on each (or some) node. It is typically used for system-level services such as monitoring agents, log collectors, or networking tools that need to run everywhere.\nStatefulSet: manages Pods that need stable, unique identities and persistent storage. It is used for stateful applications such as databases or distributed systems that need predictable network names or data persistence.\nJob: runs Pods to completion. It is used for tasks that need to run once or a fixed number of times, such as batch processing or data import. When the Job finishes successfully, the Pods are not restarted.\nConfigMap: stores non-confidential configuration data as key-value pairs. Applications can use ConfigMaps to configure themselves without having to rebuild their containers.\nSecret: similar to ConfigMap, but used to store sensitive information such as passwords, tokens, or SSH keys. Secrets are stored in base64-encoded form and can be mounted into Pods or used as environment variables. Be aware that they are not an encrypted, only encoded, so the security is ensured by having the secret saved in a private place. As such it is only moderately secured.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#everything-decoupled",
    "href": "pages/Kubernetes_introduction.html#everything-decoupled",
    "title": "Kubernetes - introduction",
    "section": "3.3 Everything decoupled",
    "text": "3.3 Everything decoupled\nHow Kubernetes makes everything through API and labels Why there is so many extra layers compared to docker compose -&gt; full decoupling.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#the-various-objects-for-your-application",
    "href": "pages/Kubernetes_introduction.html#the-various-objects-for-your-application",
    "title": "Kubernetes - introduction",
    "section": "3.4 The various objects for your application",
    "text": "3.4 The various objects for your application\nDeployment, Job, ReplicaSet, DaemonSet, StatefulSet\nWhile the Pod is the smallest element in Kubernetes, it is directly started only for testing. If you define a pod or create it using kubectl, it will only run once and will not be restarted if something fails. As such, it is like docker run if started manually, or docker compose if started using a manifest, and offers no benefit — just the added complexity of the Kubernetes setup.\nA ReplicaSet asks for a set number of pods, and Kubernetes will ensure that these pods are always running. If one pod becomes unhealthy or crashes, Kubernetes automatically removes it and creates a new one.\nA Deployment is what you usually use for applications. It manages ReplicaSets and provides updates and rollbacks. You can think of it as “the normal way” to run an app on Kubernetes — one that should always be available and easy to update.\nA Job is used for tasks that need to run once and then stop, for example, a script that imports some data or cleans up files. Kubernetes ensures that the job runs successfully to completion.\nA DaemonSet runs one pod per machine (node). This is often used for background services such as system monitoring or log collection that must run everywhere.\nA StatefulSet is like a Deployment but for applications that need to keep their identity and data across restarts — such as databases. Each pod in a StatefulSet has a fixed name and can have its own storage attached.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#visual-overview",
    "href": "pages/Kubernetes_introduction.html#visual-overview",
    "title": "Kubernetes - introduction",
    "section": "3.5 Visual overview",
    "text": "3.5 Visual overview\nHere’s a simple way to picture how Kubernetes manages your applications:\n+----------------------------------------------------+\n|                    Deployment                      |\n|  (defines the app, version, and update strategy)   |\n|                                                    |\n|   +--------------------------------------------+   |\n|   |                 ReplicaSet                 |   |\n|   |  (keeps the right number of Pods running)  |   |\n|   |                                            |   |\n|   |   +-----------+   +-----------+   +-------+|   |\n|   |   |   Pod 1   |   |   Pod 2   |   | Pod 3 ||   |\n|   |   | (runs app)|   | (runs app)|   |(app)  ||   |\n|   |   +-----------+   +-----------+   +-------+|   |\n|   +--------------------------------------------+   |\n+----------------------------------------------------+\n\nDeployment: Defines what you want to run and how to update it.\nReplicaSet: Ensures the right number of pods are running.\nPods: Run the actual container (your app).\n\nIf a pod fails, the ReplicaSet creates a new one. If you update your app, the Deployment creates a new ReplicaSet with the new version and removes the old one once everything runs correctly. —",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#updating-an-application",
    "href": "pages/Kubernetes_introduction.html#updating-an-application",
    "title": "Kubernetes - introduction",
    "section": "3.6 Updating an application",
    "text": "3.6 Updating an application\nApplications are still running in containers, so updating means updating the container image. If Deployments are used, the update is managed automatically by Kubernetes: it follows an update strategy to start new containers while stopping and removing the old ones. This allows smooth, gradual updates with no downtime.\nYou can also roll back easily if something goes wrong, as Kubernetes keeps the previous version ready.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#where-do-you-store-the-data",
    "href": "pages/Kubernetes_introduction.html#where-do-you-store-the-data",
    "title": "Kubernetes - introduction",
    "section": "3.7 Where do you store the data",
    "text": "3.7 Where do you store the data\nContainers are temporary — when they stop, everything inside disappears. For most applications, you need to keep data somewhere safe and separate from the containers. The common way to store data in Kubernetes is in volumes.\nA Volume is a piece of storage that can be attached to a pod. It can be on the same machine, on a network drive, or in the cloud. Kubernetes makes sure that your pods can access this storage whenever they run.\nIf you need data that must stay linked to a specific pod (for example, for a database), you can use a PersistentVolume and a PersistentVolumeClaim. These ensure that even if your pods are restarted or moved to another machine, your data stays available and safe.\nIn short:\n\nPods are temporary.\nData should live in Volumes or PersistentVolumes.\nKubernetes handles the connection between the app and its data storage.\n\nFor review: But you can also store your data in a database or an object storage (such as an S3 implementations). They might be part of the Kubernetes cluster, in another Kubernetes cluster, or fully external. Their access and usage will generally be the same in all cases. When within a Kubernetes cluster, they use volumes of their own and their setup could involve setting-up the volumes (see the note below). Some data storage (such as Postgresql) might be managed by an operator. Operators are software extensions of Kubernetes, that can define, as their name implies, operations on the cluster. In that case, you generally set-up the database and the operator as instructed by the operator documentation, and you will then have the database managed by the operator. They could take care of data replication, failure management, …, and are generally the prefered way to set-up a data storage on Kubernetes when something more than a simple volume is needed.\n\n\n3.7.1 A note about automatic storage (StorageClass)\nKubernetes can automatically create persistent storage for you — but only if the cluster has been set up with a storage backend.\nWhen you create a PersistentVolumeClaim (PVC), Kubernetes checks if there is a StorageClass available. The StorageClass defines how to create the actual storage — for example, on cloud disks, local drives, or network storage. If one is available, Kubernetes provisions the storage automatically and attaches it to your pod.\nIf no StorageClass or backend is configured, the claim will just wait forever (in Pending state), and your pod won’t start. So persistence only works if the cluster administrator configured it in advance.\nIn short:\n\nCloud clusters (AWS, Google, Azure) usually have a StorageClass ready by default.\nLocal or on-premise clusters might need to install one manually (for example, a local-path-provisioner or NFS).\n\n\n\n\n3.7.2 Visual overview of automatic storage provisioning\n+-----------------------------------------------+\n|                 Your Pod                      |\n|        (requests storage via PVC)             |\n+-----------------------------------------------+\n                      |\n                      v\n+-----------------------------------------------+\n| PersistentVolumeClaim (PVC)                   |\n| \"I need 10 GB of storage, please.\"            |\n+-----------------------------------------------+\n                      |\n                      v\n+-----------------------------------------------+\n| StorageClass (defines how to create storage)  |\n| Example: AWS EBS, Google PD, NFS, Local Path  |\n+-----------------------------------------------+\n                      |\n                      v\n+-----------------------------------------------+\n| PersistentVolume (PV)                         |\n| Actual disk or network storage created        |\n| automatically by the provisioner              |\n+-----------------------------------------------+\nIf a suitable StorageClass is present, the system automatically creates a PersistentVolume and binds it to your claim. Otherwise, the claim just stays pending until an administrator provides a volume manually.\n\n\n\n3.7.3 Visual overview of storage\n+----------------------------+\n|          Pod               |\n|  (runs your container app) |\n|          |                 |\n|          | uses            |\n|          v                 |\n|      +--------+            |\n|      | Volume |------------+--------------+\n|      +--------+                           |\n+-------------------------------------------|\n                                            |\n                           +--------------------------------+\n                           | PersistentVolumeClaim (PVC)    |\n                           |  (requests storage from pool)  |\n                           +--------------------------------+\n                                            |\n                           +--------------------------------+\n                           | PersistentVolume (PV)          |\n                           | (actual disk / network storage)|\n                           +--------------------------------+\n\nPod: The running container that needs to read or write data.\nVolume: The connection point between the app and the storage.\nPersistentVolumeClaim (PVC): A request for storage.\nPersistentVolume (PV): The real storage space (disk, cloud volume, etc.).\n\nThis structure lets you move or restart pods without losing any data — Kubernetes will reconnect the storage automatically.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#how-kubernetes-keeps-things-running",
    "href": "pages/Kubernetes_introduction.html#how-kubernetes-keeps-things-running",
    "title": "Kubernetes - introduction",
    "section": "3.8 How Kubernetes keeps things running",
    "text": "3.8 How Kubernetes keeps things running\nKubernetes is designed to make sure your applications stay up and running, even if something fails. It constantly watches all your pods and checks if they are healthy.\nIf a pod crashes, Kubernetes automatically restarts it or creates a new one. If a whole machine (called a node) goes down, Kubernetes moves your pods to another available machine.\nYou don’t need to manually restart or move anything — Kubernetes takes care of it. This is one of its biggest advantages compared to running containers manually: you describe what you want to run, and Kubernetes makes sure it stays that way.",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#configuration-values",
    "href": "pages/Kubernetes_introduction.html#configuration-values",
    "title": "Kubernetes - introduction",
    "section": "3.9 Configuration values",
    "text": "3.9 Configuration values\nConfigMap and Secrets\nRegular Values can be stored in a ConfigMap, while values that should be hidden are store in Secrets. The main idea of Secrets is to keep your confidential values out of the regular configuration, in a secure place. Secret values are encoded in Base64 for preventing issues with special characters but it does not offer any added security (it can be decoded with any Base64 decoding tool).",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#namespace",
    "href": "pages/Kubernetes_introduction.html#namespace",
    "title": "Kubernetes - introduction",
    "section": "3.10 Namespace",
    "text": "3.10 Namespace",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#network-access",
    "href": "pages/Kubernetes_introduction.html#network-access",
    "title": "Kubernetes - introduction",
    "section": "3.11 Network access",
    "text": "3.11 Network access",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#loadbalancing",
    "href": "pages/Kubernetes_introduction.html#loadbalancing",
    "title": "Kubernetes - introduction",
    "section": "3.12 LoadBalancing",
    "text": "3.12 LoadBalancing",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#several-deployments",
    "href": "pages/Kubernetes_introduction.html#several-deployments",
    "title": "Kubernetes - introduction",
    "section": "3.13 Several Deployments",
    "text": "3.13 Several Deployments\nkustomize\nhelm",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Kubernetes_introduction.html#sec-affinities",
    "href": "pages/Kubernetes_introduction.html#sec-affinities",
    "title": "Kubernetes - introduction",
    "section": "3.14 Affinities",
    "text": "3.14 Affinities",
    "crumbs": [
      "Home",
      "Kubernetes",
      "Kubernetes - introduction"
    ]
  },
  {
    "objectID": "pages/Costs_Limits_Troubleshooting.html",
    "href": "pages/Costs_Limits_Troubleshooting.html",
    "title": "Kubernetes - costs, limits and troubleshooting",
    "section": "",
    "text": "1 The cost of Kubernetes\nHigh complexity of some setup with less clarity than normal installation (complex Helm chart or operator).\n\n\n2 When an image does not work\nOne common issue with Docker and Kubernetes, or any other technologies using containers, is that the used images must work. Generally, with popular and well-maintained tools it isn’t an issue, but there could still be popular tools where the containerisation is an after-thought, and not always up-to-date, or older tools or less popular without an image or with an obsolete image. Or it could be a specific issue that makes this image breaks on your set-up.\nIn these cases, fixing the issue might be a high-cost operation, and a bare-metal or virtual-machine installation might help figure out the problem and fix it, or at the very last choice, be used instead."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "to_investigate.html",
    "href": "to_investigate.html",
    "title": "Scrap page: things to investigate",
    "section": "",
    "text": "All in K8 is RESTful with an unique HTTP path\nStorage: persistent volume shouldn’t be on local storage! (can be still…)\nHealth check: several kind of health check are possible, liveness and readiness\nEndpoint: service without cluster IP (like external service (p.83 and following))\nAAA\nRemote storage vs local: security benefits, cost issue\nSession handling with replicaset: load balancing or microservices and/or RESTful and/or with DB\nCloud DB: managed (AWS), specialised (PostGres k8s), “regular”, key-value\nFree K8s training:",
    "crumbs": [
      "Home",
      "Scrap pages",
      "Scrap page: things to investigate"
    ]
  },
  {
    "objectID": "to_investigate.html#structure",
    "href": "to_investigate.html#structure",
    "title": "Scrap page: things to investigate",
    "section": "Structure",
    "text": "Structure\n\nGeneral overview\nBare metal vs VM vs container vs orchestrated container\n\n\nWhy container are better adapted for cloud application\n\n\nSecurity concern, a short overview\nVM isolation vs containerization -&gt; introduction to cgroups\nImages can be compromised: VM can be created from a Linux distribution\nOnce created, VM by themselves can be more at risk (images are immutables)\n\n\nCreating an image\n\n\nShort introduction to CD/CI\n\n\nDocker and docker-compose\n\n\nK8s\nWith sample: Seek (1st) from current docker image/compose to simple pod to full deployment to helm/kustomize\nLink to section\nStorage on the cloud: scalability, issue of desynchronization, where to push the data.\nPod - Replica Sets - Deployments- DaemonSets\nDecoupled applications can gain a lot, strongly coupled might not gain anything. Same for DB&lt;-&gt;Application.\nVolumes and why they are often not a good solution (aside for DB operators)\n\nDifferent cases\nWe consider an application that need several containers: at minima one application and one database. Our example will evolve to cover a full data management application, with object storage, jobs, reverse-proxy.\n1 pod with all\nIt is possible to set-up the containers to run in one pod, i.e. not decouple anything. It is the closest configuration to a docker compose installation and the one that will offer no benefit - only added complexity - over docker compose. Thus it should only be used as a starting point to learn Kubernetes, and basically is the use case we need to break down.\n1 node with all\nWhile 1 pod with all applications is rarely desirable, 1 node with all applications is the standard situation if you use Kubernetes on one machine only (so the node). It is also suitable for application that do not need to scale, do not store a lot of data, do not expect a lot of trafic, do not need to have redundancy. So a light web-application or a simple service will often need only one node.\n1 node with 1 external DB\n1..* nodes with simple load balancing, 1 external DB\n1..* nodes with simple load balancing, 1 DB on 1st Node\n1..* nodes with simple load balancing -&gt; Daemon set for action on all nodes\n1..* nodes with simple load balancing -&gt; Object storage -&gt; local HD on 1st Node, S3 instance\n1..* nodes with load balancing, Redis\n1..* nodes with load balancing -&gt; DB managed by operator\n1..* nodes with load balancing\n– Then introduce an assembly\n\n\nVocabulary\n\n\nHow to debug & Troubleshooting\nIf possible a section with step by step troubleshooting instructions\nkubectl exec –stdin –tty bare-seek-7dc954955d-h2xd8 – /bin/bash\ninside container: more/vi/vim/ps -edf/check user/links/logs\nRemove a deployment:\nkubectl get deployments –all-namespaces\nkubectl delete -n NAMESPACE deployment DEPLOYMENT_NAME\nNot enough ressources allocated: one of the application process can be killed by the Linux watchdog (Out Of Memory (OOM) killer). In our case the main executable:\n[1]+ Killed bundle exec puma -C docker/puma.rb\nDo the simplest setup-&gt; from a docker command line use docker to docker-compose. If possible it is better than to try from a complex docker compose. Then kompose.\nUsing kompose probably a good idea to remove env variable then extract them later (to check more)",
    "crumbs": [
      "Home",
      "Scrap pages",
      "Scrap page: things to investigate"
    ]
  }
]